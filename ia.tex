\documentclass[twocolumn,titlepage,12pt]{article}

\usepackage[color=yellow]{todonotes}
\usepackage{amsmath}

% Avoid crushing TODO notes.
% I opened https://github.com/henrikmidtiby/todonotes/issues/29 about this problem.
\setlength{\marginparwidth}{2cm}

\bibliographystyle{plain}

\begin{document}
\title{The Real Y Combinator:  Creating Functional Recursion in a Language Without It}
\author{Erik Boesen, Candidate gsg256}
\date{\parbox{\linewidth}{\centering%
  \today\endgraf\bigskip
  Ms. Jennifer Jayson \& Mr. William Snyder\endgraf\medskip
  IB High Level Math\endgraf\medskip
  George Mason High School}}
\maketitle
\begin{abstract}
We explain the basics of the lambda calculus, an alternate system of mathematical notation and functional representation created in the 1930s by Princeton mathematician Alonzo Church. We take advantage of this new intuition to explain the Y combinator, a simple yet powerful construct for simulating the process of recursion in a mathematical language lacking such a concept or even the ability to name functions.
\end{abstract}

\section{What is the Lambda Calculus?}
The lambda calculus (sometimes notated ``$\lambda$-calculus'') is a system of mathematical notation and logic developed for the study of the elementary properties of functions \cite{rojastutorial}.

The notation and concept of the lambda calculus was first described in the 1930s by Alonzo Church \cite{church}.\footnote{Church later published a revision \cite{church2} of the system after other researchers\cite{logicallyinconsistent} criticized it as logically inconsistent. This brought the calculus to roughly its current form.} Despite lacking many attributes of standard maths, the system can be used to represent any computation traditionally possible. Even complex computations such as traditional differential calculus \cite{differentiallc}---the calculus learned by millions of students, this year including ourselves, each year in high school classrooms---can be represented using the lambda calculus. So, it is equivalent in capability to a ``Turing machine''---a mathematical notion of a computer.\footnote{Both Church and Alan Turing, who proposed the idea of Turing machines, sough to solve the \textit{Entscheidungsproblem}. Translating to ``decision problem'', this question was posed by logician David Hilbert in 1928, and asked whether an algorihm can be devised to take as input a first-order logical construction, and output a boolean (true or false, yes or no) stating whether that logical construction is universally valid. Both Church and Turing answered that such an algorithm could not exist, but did so independently and in different countries. Church used the new construct of the lambda calculus to respond to the problem, while Turing used the competing---and comparatively simple---construct of the Turing machine. Interestingly, despite their sometimes conflicting ideas on computation, Turing studied as a Ph. D. candidate under Church from 1936 to 1938 \cite{churchpapers}.}

More recently, the system and its logical process has gained new notoriety as the basis for new forms of computer programming. The lambda calculus is a ``universal programming language'' \cite{rojastutorial}, and can, on its own, represent and perform the computations of a Turing machine and vice versa, even without a computer to run it. The lambda calculus is the basis for functional programming languages, or those whose attributes include treating functions as data and using a declarative programming paradigm\footnote{Declarative programming refers to the style of programming or mathematical notation where logic, not control flow, of a program is defined \cite{declarativeprogadv}. So, rather than specifying a sequence of instructions, a declarative programmer would specify what functions do in a non-sequential manner. In short, while non-declarative (``imperative'') programming involves determination of what a function should \textit{do}, declarative programming emphazies what a function \textit{is}.}\todo{Is the footnote a reasonable explanation to a non-programmer?} \cite{hudakevolution}. Despite being the reason we investigate The topic of functional programming is beyond the scope of this paper, however, interested readers are invited to investigate the topic through papers including \cite{totalfp} and \cite{hudakevolution}.

\section{Notation}
The notation used to describe lambda calculus expressions seldom bears intentional resemblance to more traditional systems of mathematical notation. To describe, for instance, the identity function (in which a single parameter is given as input and is outputted without modification) in traditional notation, one would likely use some variation upon:
$$f(x)=x$$
To make the function anonymous in traditional notation, one could use a ``map'' expression \cite{intrographtheory}, which simply enumerates the parameters to a function and, following the map symbol $\mapsto$, gives the function's internal logic:
$$x\mapsto x$$
Any function can easily be translated to use anonymous mapping. For example, the function for finding the length of a three-dimensional vector
$$L(x,y,z)=\sqrt{x^2+y^2+z^2}$$
would become
$$(x,y,z) \mapsto \sqrt{x^2+y^2+z^2}$$
Understanding this syntax, the transition to lambda calculusÂ notation is relatively intuitive. Let us return to our identity map $x\mapsto x$ from above. In the lambda calculus, an anonymous identity function would be notated thus:
$$\lambda x.x$$
Some explanation of the symbolic logic used herein is in order. Only two operational symbols in the calculus are defined, $\lambda$ and $.$ (some other symbols, such as parentheses, are used intuitively for grouping and other purposes). The former is used to represent a function definition, whereas the latter separates parameters from that function's internal logic. The sum of those two components is referred to as an ``abstraction.'' The lambda calculus also defines ``applications:'' the \textit{application} of a function to a parameter \cite{horowitz}.

Lambda calculus expressions associate left-to-right. So, lambda applications can be created simply by parenthesizing an expression and appending a parameter afterward. The process of substituting a parameter into a lambda function is known as $\beta$-reduction (beta-reduction). So, to apply our identity function to some constant $C$, we would perform the following lambda computation:
$$(\lambda x.x)C$$
$$=\lambda x.C$$
$$=C$$

The important thing to note about the aforementioned syntax is that in pure lambda calculus, there are no other symbols or gramatical constructions used. This leads to some occasionally verbose definitions for otherwise simple concepts. Basic mathematical functions are generally defined through several facilities. The first important thing to know in order to redefine things like addition is the ``successor'' function:
$$$$


Throughout this paper, we will generally try to keep to the pure lambda calculus where possible, however, given that this is typically inconvenient,

\section{Currying}
The lambda calculus' syntax for representation of multi-parameter functions is potentially surprising. Purely speaking, there is no notion of multi-parameter functions. Rather, the lambda calculus makes use of ``currying,'' a technique named after mathematician Haskell Curry. In this process, a function which would typically require multiple parameters transforms into a series of functions requiring only one parameter each. So,
$$\lambda xyz.x+y+z$$\todo{Use pure equation somehow?}
would expand to
$$\lambda x.\lambda y.\lambda z.x+y+z$$
These two expressions are equivalent, assuming that the impure syntax used in the first represents one function with three parameters $x$, $y$, and $z$. Let us see how this expression would be applied:
$$(\lambda x.\lambda y.\lambda z.x+y+z)ABC$$
The outer function would be applied first, and the single parameter it accepts, $x$, would be substituted into the body\todo{Right name?} of the enclosed function. So, the above expression would first simplify as follows:
$$(\lambda y.\lambda z.A+y+z)BC$$
$$(\lambda z.A+B+z)C$$
$$A+B+C$$

\section{Recursion}
One of the most bizarre characteristics of the lambda calculus is its lack of natural support for naming functions. A consequence of this deficit is that the process of ``recursion'' is not as easy as one might be accustomed to.

Recursion is a technique used frequently within the field of computer science, but it finds much use within mathematical operations as well. A classic example of recursion is a redefinition of the factorial operator:
\[
factorial(x)=
\begin{cases}
    x\times factorial(x-1) & x>1 \\
    1 & x\leq 1
\end{cases}
\]
This function may appear initially confusing. An illustration may help. Let us take the factorial of the integer $4$. First, we begin with our initial call to the function:
$$factorial(4)$$
As $4>1$, the first case is met, so:
$$factorial(4)=4\times factorial(3)$$
From here, we can clearly see how the expression will expand.
$$factorial(4)$$
$$=4\times factorial(3)$$
$$=4\times 3\times factorial(2)$$
$$=4\times 3\times 2\times factorial(1)$$
Since evaluating $factorial(1)$ uses the ``base case'' of $factorial$, the expression will evaluate to:
$$4\times 3\times 2\times 1=24$$

\section{The Y Combinator}
Since lambda expressions are anonymous, no strategy for programatic recursion using the notation is immediately evident. However, it is possible to create recursion using the lambda calculus. To do so, we must implement the ``Y combinator.''\cite{ycombmedium} Though the name of the method is known better as that of a Silicon Valley startup corporation incubator, the Y combinator originated in the lambda calculus as a useful tool for simulating recursion even in a calculus lacking names or otherwise not allowing for recursive computation. This technique was discovered by mathematician Haskell Curry, whom you may remember as the namesake of the process of currying.

To understand how the Y combinator works, we need to recall how lambda expressions associate. Lambda expressions are ``left-associative,'' meaning that the leftmost function in an application will be evaluated first, and expressions to the right of one expression will be used as parameters to that on the left. \textit{Any} expression can be substituted as a parameter to a function. So:
$$(\lambda x.xx)\lambda x.x$$
$$=(\lambda x.x)(\lambda x.x)$$
$$=\lambda x.x$$

The Y combinator may be expressed as follows:
$$Y=\lambda f.(\lambda x.f(x x))(\lambda x.f(x x))$$
Let us analyze the individual parts of this expression in order to understand how it allows for recursion.

We first need to

\section{Conclusion}


\section{Reflection}
I first chose to research the lambda calculus due to my extant interest within the field of computer science. I've had past experience with the functional programming paradigm, the study of which was a truly transformative experience. Conventional programming---with languages like C, Java, Python, etc.---is structured around traditional mathematical structures. When I learned about functional programming, I occasionally heard references to the lambda calculus, an apparently mysterious and confusing alternate form for mathematical syntax and logic.
Through this IA, I had an excellent opportunity to dive into the new and fascinating notion of this calculus, and the incredible idea that any computation can be represented using only two predefined symbols.

\bibliography{research}
\end{document}
