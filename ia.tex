\documentclass{article}

\usepackage{todonotes}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}

\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\bibliographystyle{plain}

\begin{document}
\title{The Real Y Combinator:Â Simulating Recursion in a Language Without It}
\author{Erik Boesen}
\maketitle
\todo{Consider more specific title}
\begin{abstract}
We explain the basics of the lambda calculus, an alternate system of functional representation and mathematical representation. We take advantage of this new intuition to explain the Y combinator, a simple yet powerful construct for simulating the process of recursion in a mathematical language lacking such a concept.
\end{abstract}

\section{What is the Lambda Calculus?}
The lambda calculus (hereinafter notated as ``the lambda calculus'') is a system of mathematical notation and logic developed for the study of the elementary properties of functions \cite{rojastutorial}.

The notation and concept of the lambda calculus was first described in 1930 by Alonzo Church \cite{church}.\footnote{It underwent revisions following criticism as logically invalid \cite{church2}.} The system can be used to represent any computation traditionally possible. So, it is equivalent in capability to a ``Turing machine''---a mathematical notion of a computer.

Later, the system of notation gained new notoriety as the basis for new forms of computer programming. The lambda calculus is sometimes referred to as a universal programming language \cite{rojastutorial}, given that it can represent and perform the computations of a Turing machine and vice versa. The lambda calculus is the basis for functional programming languages, or those whose attributes including treating functions as data and using a declarative programming paradigm \cite{hudakevolution}. The topic of functional programming is beyond the scope of this paper, however, interested readers are invited to investigate the topic through papers including \cite{totalfp} and \cite{hudakevolution}.

\section{Notation}
The notation used to describe lambda calculus expressions seldom bears resemblance to more traditional systems of mathematical notation. To describe, for instance, the identity function (in which a single parameter is given as input and is outputted without modification) in traditional notation, one would likely use some variation upon:
$$f(x)=x$$
To make the function anonymous in traditional notation, one could use:
$$(x) \mapsto x$$
In the lambda calculus, however, an anonymous identity function would be notated thus:
$$\lambda x.x$$
Lambda calculus expressions associate left-to-right. So, Lambda expressions can be applied simply by parenthesizing them and appending parameters afterward. So, to apply our identity function to some constant $C$, we would perform the following lambda computation:
$$(\lambda x.x)C$$
$$=\lambda x.C$$
$$=C$$
Some explanation of the symbolic logic used herein is in order. Only two symbols in the calculus are defined, $\lambda$ and $.$ (some other symbols, such as parentheses, are used intuitively for grouping and other purposes). The former is used to represent a function definition, whereas the latter separates parameters from that function's internal logic. The sum of those two components is referred to as an ``abstraction.'' The lambda calculus also defines ``applications,'' or one lambda expression applied to another \cite{horowitz}.

The important thing to note about the aforementioned syntax is that in pure lambda calculus, there are no other symbols or gramatical constructions used. This leads to some occasionally verbose definitions for otherwise simple concepts. Basic mathematical functions are generally defined through several facilities. The first important thing to know in order to redefine things like addition is the ``successor'' function:
$$$$


Throughout this paper, we will generally try to keep to the pure lambda calculus where possible, however, given that this is typically inconvenient,

\section{Currying}
The lambda calculus' syntax for representation of multi-parameter functions is potentially surprising. Purely speaking, there is no notion of multi-parameter functions. Rather, the lambda calculus makes use of ``currying,'' a technique named after mathematician Haskell Curry. In this process, a function which would typically require multiple parameters transforms into a series of functions requiring only one parameter each. So,
$$\lambda xyz.x+y+z$$\todo{Use pure equation somehow?}
would expand to
$$\lambda x.\lambda y.\lambda z.x+y+z$$
These two expressions are equivalent, assuming that the impure syntax used in the first represents one function with three parameters $x$, $y$, and $z$. Let us see how this expression would be applied:
$$(\lambda x.\lambda y.\lambda z.x+y+z)ABC$$
The outer function would be applied first, and the single parameter it accepts, $x$, would be substituted into the body\todo{Right name?} of the enclosed function. So, the above expression would first simplify as follows:
$$(\lambda y.\lambda z.A+y+z)BC$$
$$(\lambda z.A+B+z)C$$
$$A+B+C$$

\section{Recursion and the Y Combinator}
One of the most bizarre characteristics of the lambda calculus is its lack of natural support for naming functions. A consequence of this deficit is that recursion---or, the calling of a function within its own body---is impossible.

In standard mathematical notation or while writing code for a Turing machine (computer), one might define a function such as the factorial as follows:
$$factorial(x)=x*factorial(x-1)$$
This is an example of recursion.

Since lambda expressions are anonymous, no strategy for programatic recursion using the notation is immediately evident. However, it is possible to create recursion using the lambda calculus. To do so, we must implement the ``Y combinator.'' This technique was discovered by mathematician Haskell Curry, whom you may remember as the namesake of the process of currying.

The Y combinator may be expressed as follows:
$$Y=\lambda f.(\lambda x.f(x x))(\lambda x.f(x x))$$
Let us

\bibliography{research}
\end{document}
